# 5. 常见编程特性

## 5.1 超时设置 timeout

超时设置 timeout

## 5.2 自动重试 retry

在开放环境中运行，模块运行中会有非逻辑错的异常。非逻辑错的自动处理，将使得大规模数据处理的运行可靠，支持产生可信的科学产出。

### 5.2.1 模块运行异常的现象
- 不稳定的硬件和基础软件
  - 网络不稳定
  - 部分计算节点硬件故障
  - 集群存储软件的bug
- 运行中的随机异常
  - 高负载导致核心存储响应延时增加
  - 高负载导致低概率的内存超分（Core Dump）
  - 网络存储的异常
    - 可变延时（数秒~几分钟）
    - 暂时性不可写入
- 数据异常
  - 异常输入数据
  - 前导处理软件的随机错误
  - 各类运行异常导致的数据不完整

### 5.2.2 容错处理
- 系统异常的判断与定位
  - 读取/执行/回写的时间
  - 任务返回码
  - 系统监控的异常信息
- 异常任务的容错处理
  - 自动/人工

### 5.2.3 运行出错的自动重试（retry）



## 5.3 流控设置

###  业务代码精准流控
精准控制数据输出，若数据空间不满足，在代码中显式调用sleep()，等待其他并行任务完成，清理出空间，待空间容量满足要求后再继续运行。

避免内存空间的峰值需求，以增加等待时间为代价，在低内存配置的机器上运行本地计算的应用。


流控是控制每个task运行进度的机制。

### 5.3.1 task级流控
- 标准流控属性（job间流控）
  - dir_limit_gb
  - dir_free_gb
- 代码定制流控（可基于信号量）
  - ACTION_CHECK/check.sh

### 5.3.2 node间并行同步流控
- 标准流控属性
  - 按节点的进度计数器，基于同步信号量实现
  - progress_counter_diff：当前节点进度与最慢进度的差值作为控制变量

- 代码定制流控
  - 基于ACTION_CHECK/check.sh，自定义逻辑

流控支持模块运行的同步，以免系统资源受限而导致系统异常。分为系统级流控、自定义流控两类。

系统级流控通过设置parameters的xx属性实现，而自定义流控通过程序代码实现。

- 系统级流控

目前支持通过限制目录大小实现流控。


- 自定义流控

通过系统脚本/app/bin/check.sh实现

## 5.4 关键路径上的模块task排序

- key_group_regex
- key_group_index
- sorted_tag


## 5.5 多GPU配置

## 5.6 共享变量与信号量

信号量是scalebox中用于任务间同步的重要概念，在复杂应用逻辑场景下，集中管理全系统的运行状态，使得计算模块无状态。信号量通常仅在message-router中被调用，以避免并发导致的问题。					

### 信号量名称的命名规范



## 5.7 task-perspective

task-perspective

## 5.8 git应用代码库
